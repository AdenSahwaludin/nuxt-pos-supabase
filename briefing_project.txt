# Nuxt POS System with Supabase (SBS)
## Technical Specification & Implementation Guide

> **Architecture:** Client-Side Rendering (CSR) only  
> **Framework:** Nuxt 3  
> **Database:** Supabase (PostgreSQL + Row Level Security)  
> **Schema:** `sbs`  
> **User Roles:** `admin` & `kasir` (cashier)

---

## Table of Contents
1. [Environment Configuration](#environment-configuration)
2. [Nuxt 3 Project Setup](#nuxt-3-project-setup)
3. [Database Schema Design](#database-schema-design)
4. [ID Generation System](#id-generation-system)
5. [POS Workflow](#pos-workflow)
6. [User Role Management](#user-role-management)
7. [UI Components](#ui-components)
8. [Implementation Examples](#implementation-examples)
9. [Data Seeding](#data-seeding)
10. [Acceptance Criteria](#acceptance-criteria)
11. [Performance Guidelines](#performance-guidelines)
12. [Future Enhancements](#future-enhancements)

---

## Environment Configuration

### Required Environment Variables

```env
SUPABASE_URL=https://mjxhddjoaoekdlhnqbhy.supabase.co
SUPABASE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1qeGhkZGpvYW9la2RsaG5xYmh5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQxNTgxMTQsImV4cCI6MjA2OTczNDExNH0.XyPUtr2KgiZwMqbz_2hS0e-UTVqhS-ucZedo0pT9Qss
```

> **Security Note:** These are client-side public keys. For server-side privileged operations, use the Service Role key (server-side only). This project runs in CSR mode, so avoid exposing sensitive secrets to the client.

## Nuxt 3 Project Setup

### Core Configuration

**nuxt.config.ts**

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: false, // Client-side rendering only
  devtools: { enabled: true },
  modules: [
    '@nuxt/ui',
    '@nuxt/image',
    '@nuxt/eslint',
    '@nuxt/scripts'
  ],
  runtimeConfig: {
    public: {
      supabaseUrl: process.env.SUPABASE_URL,
      supabaseAnonKey: process.env.SUPABASE_KEY
    }
  },
  typescript: { strict: true },
  app: { 
    pageTransition: { name: 'page', mode: 'out-in' } 
  }
})
```

### Supabase Client Configuration

**~/lib/supabaseClient.ts**

```typescript
import { createClient } from '@supabase/supabase-js'

const config = useRuntimeConfig()

export const supabase = createClient(
  config.public.supabaseUrl!,
  config.public.supabaseAnonKey!,
  { 
    auth: { 
      persistSession: true, 
      autoRefreshToken: true, 
      detectSessionInUrl: true 
    } 
  }
)
```

### State Management (Pinia)

**~/stores/auth.ts**

```typescript
import { defineStore } from 'pinia'
import { supabase } from '~/lib/supabaseClient'

export const useAuthStore = defineStore('auth', {
  state: () => ({ 
    user: null as any, 
    profile: null as any 
  }),
  
  actions: {
    async signIn(email: string, password: string) {
      const { data, error } = await supabase.auth.signInWithPassword({ 
        email, 
        password 
      })
      if (error) throw error
      
      this.user = data.user
      await this.loadProfile()
    },
    
    async signOut() {
      await supabase.auth.signOut()
      this.user = null
      this.profile = null
    },
    
    async loadProfile() {
      const uid = (await supabase.auth.getUser()).data.user?.id
      if (!uid) return
      
      const { data } = await supabase
        .from('sbs_pengguna_view')
        .select('*')
        .single()
      this.profile = data
    }
  }
})
```

### Authentication Middleware

**~/middleware/auth.global.ts**

```typescript
export default defineNuxtRouteMiddleware((to) => {
  const auth = useAuthStore()
  const publicRoutes = ['/login']
  
  if (!auth.user && !publicRoutes.includes(to.path)) {
    return navigateTo('/login')
  }
})
```

**~/middleware/role.ts**

```typescript
export default defineNuxtRouteMiddleware((to) => {
  const auth = useAuthStore()
  const needAdmin = to.meta?.role === 'admin'
  
  if (needAdmin && auth.profile?.role !== 'admin') {
    return navigateTo('/forbidden')
  }
})
```

### Layout Components

**~/layouts/admin.vue**

```vue
<template>
  <div class="min-h-screen grid grid-rows-[auto,1fr]">
    <header class="p-4 border-b flex items-center justify-between">
      <div class="font-bold">SBS Admin Dashboard</div>
      <div>
        <UButton @click="logout" variant="outline">
          Logout
        </UButton>
      </div>
    </header>
    <main class="p-4">
      <slot />
    </main>
  </div>
</template>

<script setup lang="ts">
import { useAuthStore } from '~/stores/auth'

const auth = useAuthStore()
const logout = () => auth.signOut()
</script>
```

**~/layouts/kasir.vue**

```vue
<template>
  <div class="min-h-screen">
    <header class="p-3 border-b flex items-center gap-3">
      <div class="font-semibold">SBS Cashier</div>
      <UButton to="/pos" size="sm" color="primary">
        Mulai Transaksi
      </UButton>
      <div class="ml-auto">
        <UButton @click="logout" size="sm" variant="outline">
          Logout
        </UButton>
      </div>
    </header>
    <main class="p-4 max-w-6xl mx-auto">
      <slot />
    </main>
  </div>
</template>

<script setup lang="ts">
import { useAuthStore } from '~/stores/auth'

const auth = useAuthStore()
const logout = () => auth.signOut()
</script>
```

### Page Structure

```
pages/
├── login.vue                    # Email/password authentication form
├── dashboard/
│   └── index.vue               # Role detection → redirect to /admin or /kasir
├── admin/
│   └── index.vue               # Admin dashboard (layout: admin, meta: { role: 'admin' })
├── kasir/
│   └── index.vue               # Cashier dashboard (layout: kasir)
├── pos/
│   └── index.vue               # POS interface: cart, scan, payment options
└── forbidden.vue               # Access denied page
```

## Database Schema Design

### Overview

The database schema follows a comprehensive design pattern for a Point of Sale system with credit/installment capabilities. All tables include proper indexing, timestamps, and Row Level Security (RLS) for data protection.

**Key Features:**
- Customer ID format: `P001` to `P999` (3-digit incremental)
- Transaction ID format: `INV-YYYY-MM-SEQ-PELANGGAN`
- Payment ID format: `PAY-YYYYMMDD-SEQ`
- Accounts Receivable ID format: `AR-YYYYMM-SEQ`
- Legacy password field (nullable) - authentication handled by Supabase Auth

### Schema Initialization

```sql
-- pastikan schema sbs ada
create schema if not exists sbs;

set search_path to sbs, public;
create type user_role as enum ('admin','kasir');
create type trx_status as enum ('menunggu','selesai','dibatalkan');
create type pay_method as enum ('tunai','non_tunai','cicilan');
create type ar_status as enum ('aktif','lunas','tunggakan','gagal');

--BATAS

create table if not exists pengguna (
id_pengguna char(7) primary key check (id_pengguna ~ '^[0-9]{3}-[A-Z]{2,4}$'),
nama varchar(100) not null,
email varchar(50) unique,
telepon varchar(20),
kata_sandi char(60), -- legacy
user_id uuid unique references auth.users(id) on delete cascade,
role user_role not null default 'kasir',
terakhir_login timestamptz,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

--BATAS

create table if not exists pelanggan (
id_pelanggan varchar(4) primary key check (id_pelanggan ~ '^P[0-9]{3}$'),
nama varchar(100) not null,
email varchar(50) unique,
telepon varchar(20), kota varchar(50), alamat text,
aktif boolean not null default true,
tanggal_daftar date default current_date,
allow_installment boolean not null default false,
credit_limit numeric(12,2) not null default 0.00,
max_tenor_bulan smallint not null default 0,
trust_score numeric(5,2) not null default 0,
created_at timestamptz default now(), updated_at timestamptz default now()
);

--BATAS

create table if not exists produk (
id_produk char(13) primary key,
kategori varchar(100) not null,
nama varchar(100) not null,
gambar varchar(255), nomor_bpom varchar(50),
harga numeric(12,2) not null check (harga >= 0),
biaya_produk numeric(12,2) not null default 0 check (biaya_produk >= 0),
stok integer not null default 0, batas_stok integer not null default 0,
-- pricing pack & tier (tanpa tabel tambahan)
unit varchar(20) default 'pcs',
pack_unit varchar(20) default 'karton',
pack_size int not null default 1, -- isi per karton (mis. 144)
harga_pack numeric(12,2), -- harga per karton (total)
qty_tier1 int, harga_tier1 numeric(12,2), -- tier pcs: min qty & harga/pcs
harga_tier_qty int, -- ambang karton untuk tier pack (opsional)
harga_tier_pack numeric(12,2), -- harga per karton khusus jika >= ambang
created_at timestamptz default now(), updated_at timestamptz default now()
);
create index if not exists idx_produk_kategori on produk(kategori);

--BATAS

create table if not exists transaksi (
id_transaksi varchar(28) primary key,
id_pengguna char(7) not null references pengguna(id_pengguna),
id_pelanggan varchar(4) not null references pelanggan(id_pelanggan),
tanggal timestamptz not null default now(),
status trx_status not null default 'menunggu',
total numeric(12,2) not null check (total >= 0),
diskon numeric(12,2) check (diskon is null or diskon >= 0),
pajak numeric(12,2) check (pajak is null or pajak >= 0),
biaya_pengiriman numeric(12,2) default 0 check (biaya_pengiriman >= 0),
is_credit boolean not null default false,
dp_amount numeric(12,2) default 0 check (dp_amount >= 0),
tenor_bulan smallint, due_date date,
outstanding numeric(12,2) default 0 check (outstanding >= 0),
ar_status ar_status,
created_at timestamptz default now(), updated_at timestamptz default now()
);
create index if not exists idx_transaksi_tanggal on transaksi(tanggal);
create index if not exists idx_transaksi_pelanggan on transaksi(id_pelanggan);

--BATAS

create table if not exists transaksi_detail (
id_detail bigserial primary key,
id_transaksi varchar(28) not null references transaksi(id_transaksi) on delete cascade,
id_produk char(13) not null references produk(id_produk),
jumlah integer not null check (jumlah > 0),
harga_satuan numeric(12,2) not null check (harga_satuan >= 0),
subtotal numeric(14,2) generated always as ((jumlah::numeric * harga_satuan)) stored
);
create index if not exists idx_trx_detail_trx on transaksi_detail(id_transaksi);
create index if not exists idx_trx_detail_produk on transaksi_detail(id_produk);

--BATAS

create table if not exists piutang (
id_piutang varchar(30) primary key,
id_transaksi varchar(28) not null unique references transaksi(id_transaksi) on delete cascade,
id_pelanggan varchar(4) not null references pelanggan(id_pelanggan),
tenor_bulan smallint not null check (tenor_bulan > 0),
dp_amount numeric(12,2) not null default 0 check (dp_amount >= 0),
principal numeric(12,2) not null check (principal >= 0),
bunga_persen numeric(5,2) not null default 0 check (bunga_persen >= 0),
total_tagihan numeric(12,2) not null check (total_tagihan >= 0),
outstanding numeric(12,2) not null check (outstanding >= 0),
start_date date not null default current_date, end_date date,
jadwal jsonb not null check (jsonb_typeof(jadwal)='array'), -- [{termin_ke,due_date,amount_due,amount_paid,paid_date,denda,status}]
status ar_status not null default 'aktif',
approved_by char(7) references pengguna(id_pengguna),
created_at timestamptz default now(), updated_at timestamptz default now()
);
create index if not exists idx_piutang_pelanggan on piutang(id_pelanggan);
create index if not exists idx_piutang_status on piutang(status);

--BATAS

create table if not exists pembayaran (
id_pembayaran char(20) primary key,
id_transaksi varchar(28) not null references transaksi(id_transaksi),
metode pay_method not null,
jumlah numeric(12,2) not null check (jumlah > 0),
tanggal timestamptz not null default now(),
keterangan varchar(255),
id_piutang varchar(30) references piutang(id_piutang),
termin_ke smallint
);
create index if not exists idx_pembayaran_trx on pembayaran(id_transaksi);
create index if not exists idx_pembayaran_piutang on pembayaran(id_piutang);
create index if not exists idx_pembayaran_tanggal on pembayaran(tanggal);

--BATAS

alter table pengguna enable row level security;
alter table pelanggan enable row level security;
alter table produk enable row level security;
alter table transaksi enable row level security;
alter table transaksi_detail enable row level security;
alter table piutang enable row level security;
alter table pembayaran enable row level security;


create or replace view sbs_pengguna_view as select p.* from pengguna p where p.user_id = auth.uid();


create policy r_all_pengguna on pengguna for select using (auth.uid() is not null);
create policy r_all_pelanggan on pelanggan for select using (auth.uid() is not null);
create policy r_all_produk on produk for select using (auth.uid() is not null);
create policy r_all_trx on transaksi for select using (auth.uid() is not null);
create policy r_all_detail on transaksi_detail for select using (auth.uid() is not null);
create policy r_all_piutang on piutang for select using (auth.uid() is not null);
create policy r_all_bayar on pembayaran for select using (auth.uid() is not null);


create policy w_admin_produk on produk for all using (exists (select 1 from pengguna where user_id=auth.uid() and role='admin')) with check (exists (select 1 from pengguna where user_id=auth.uid() and role='admin'));
create policy w_kasir_trx on transaksi for insert with check (exists (select 1 from pengguna where user_id=auth.uid() and role in ('kasir','admin')));
create policy w_kasir_bayar on pembayaran for insert with check (exists (select 1 from pengguna where user_id=auth.uid() and role in ('kasir','admin')));

```

## ID Generation System

### Client-Side ID Generators

These lightweight functions generate consistent IDs on the client side. For production use, consider implementing server-side RPC functions for atomic sequence generation.

#### Customer ID Generator

```typescript
/**
 * Generate next customer ID in format P001-P999
 * @param last - Last used customer ID
 * @returns Next customer ID
 */
export function nextPelangganId(last: string | null): string {
  const n = last ? parseInt(last.slice(1), 10) + 1 : 1
  return `P${String(n).padStart(3, '0')}`
}
```

#### Transaction ID Generator

```typescript
/**
 * Generate transaction ID in format INV-YYYY-MM-SEQ-PELANGGAN
 * @param seq - Sequence number for the month
 * @param pelId - Customer ID
 * @returns Transaction ID
 */
export function buildTrxId(seq: number, pelId: string): string {
  const d = new Date()
  const yyyy = d.getFullYear()
  const mm = String(d.getMonth() + 1).padStart(2, '0')
  const s = String(seq).padStart(3, '0')
  return `INV-${yyyy}-${mm}-${s}-${pelId}`
}
```

#### Payment ID Generator

```typescript
/**
 * Generate payment ID in format PAY-YYYYMMDD-SEQ
 * @param seq - Daily sequence number
 * @returns Payment ID
 */
export function buildPayId(seq: number): string {
  const d = new Date()
  const y = d.getFullYear()
  const m = String(d.getMonth() + 1).padStart(2, '0')
  const day = String(d.getDate()).padStart(2, '0')
  return `PAY-${y}${m}${day}-${String(seq).padStart(3, '0')}`
}
```

#### Accounts Receivable ID Generator

```typescript
/**
 * Generate accounts receivable ID in format AR-YYYYMM-SEQ
 * @param seq - Monthly sequence number
 * @returns AR ID
 */
export function buildArId(seq: number): string {
  const d = new Date()
  const y = d.getFullYear()
  const m = String(d.getMonth() + 1).padStart(2, '0')
  return `AR-${y}${m}-${String(seq).padStart(3, '0')}`
}
```

> **Production Tip:** For cross-client consistency, implement a `seq_counter(table, scope)` table with atomic upsert via Supabase Edge Functions.

## POS Workflow

### Cashier Transaction Flow

The POS system follows a streamlined workflow optimized for performance with pagination and lightweight operations.

#### 1. Product Search & Selection

- **Barcode Scan**: Query `produk` table by exact barcode match (limit 1)
- **Name Search**: Query by product name with pagination (limit 20, debounced 250ms)
- **Category Filter**: Optional filtering by product category

#### 2. Shopping Cart Management

- **State Management**: Store cart items in Pinia state (client-side)
- **Tiered Pricing**: Query `sbs.harga_aturan` for quantity-based pricing
- **Real-time Calculation**: Auto-calculate subtotals and totals

#### 3. Checkout Process

Create transaction and details in sequential batch operations:
- Insert `transaksi` record
- Insert multiple `transaksi_detail` records
- For atomic consistency in production, consider implementing RPC functions

#### 4. Payment Methods

**Cash/Non-Cash Payments:**
- Insert `pembayaran` record (without `id_piutang`/`id_jadwal`)
- Update transaction status to 'selesai'

**Installment Payments (Credit-Eligible Customers):**
- Create `piutang` header record (principal = total - down payment)
- Generate `piutang_jadwal` entries (monthly installments with due dates)
- Insert `pembayaran` record for down payment (linked to `piutang`)
- Calculate interest if applicable

### Credit Eligibility System

**Frontend Validation + Backend Verification:**

1. **Customer-Specific Override**: Check `kebijakan_cicilan_per_pelanggan`
   - Allow/deny installment capability
   - Custom credit limits and tenor periods
   - Minimum down payment percentage

2. **Global Policy Fallback**: Use `kebijakan_cicilan` default rules
   - Minimum membership duration
   - Minimum 3-month purchase history
   - Trust score requirements

3. **Metric-Based Assessment**: Evaluate `pelanggan_metric_snapshot`
   - 3-month total spending
   - Transaction frequency
   - On-time payment rate
   - Current outstanding balances

4. **Real-time Display**: Show eligibility status with clear rejection reasons
   - Trust score below minimum
   - Insufficient purchase history
   - Existing overdue payments

## User Role Management

### Administrator Functions

**Master Data Management:**
- Product catalog (CRUD operations)
- Category management
- Customer profiles and credit settings

**Credit Policy Administration:**
- Global installment policies
- Customer-specific overrides
- Credit limit adjustments

**Financial Monitoring:**
- Accounts receivable dashboard
- Installment schedule tracking
- Aging analysis and collection reports

**Operational Reports:**
- Daily sales summaries
- Low stock alerts
- Performance metrics

### Cashier Functions

**Point of Sale Operations:**
- Transaction processing
- Multi-tier pricing application
- Payment method selection (cash/credit/installment)

**Customer Service:**
- Transaction history lookup
- Customer credit status inquiry
- Basic account information

**Personal Tracking:**
- Individual transaction history
- Personal performance metrics

### Route Configuration Example

```typescript
// pages/admin/index.vue
<script setup>
definePageMeta({ 
  layout: 'admin', 
  middleware: ['role'], 
  role: 'admin' 
})
</script>
```

## UI Components

### Key POS Interface Components

**ProductSearch.vue** - Product Discovery
- Search input with debounced queries (250ms delay)
- Virtualized product list for large catalogs
- Pagination support (20-50 items per page)
- Barcode scanner integration
- Category filtering capabilities

**CartTable.vue** - Shopping Cart Management
- Responsive table layout for cart items
- Quantity adjustment controls
- Price tier indicators and hints
- Subtotal calculations
- Item removal functionality

**CheckoutPanel.vue** - Payment Processing
- Payment method selection (cash/credit/installment)
- Down payment input for credit transactions
- Tenor (installment period) selector
- Transaction summary display
- Customer eligibility status

**EligibilityBadge.vue** - Credit Status Display
- Visual credit eligibility indicator
- Detailed reason display for rejections
- Customer trust score visualization
- Credit limit and available balance

### Performance Optimization Guidelines

**Database Query Optimization:**
- Use specific column selection: `select('column1,column2')` instead of `select('*')`
- Implement pagination with `.range(start, end)` for large datasets
- Leverage existing database indexes for optimal query performance

**Frontend Performance:**
- Implement infinite scroll or pagination for large lists
- Cache master data (categories, policies) in Pinia with periodic refresh
- Use debounced search inputs (200-300ms delay)
- Implement virtual scrolling for large product catalogs

**Memory Management:**
- Clear unnecessary state after transactions
- Optimize image loading with lazy loading
- Use efficient data structures for cart management

## Implementation Examples

### Credit Transaction Checkout

```typescript
// Composable: ~/composables/useCheckout.ts
import { supabase } from '~/lib/supabaseClient'

interface CreditTransactionPayload {
  pelangganId: string
  penggunaId: string
  items: Array<{
    id_produk: string
    qty: number
    harga: number
  }>
  diskon?: number
  pajak?: number
  biaya_pengiriman?: number
  dp: number
  tenor: number
  bunga: number
}

export async function createCreditTransaction(payload: CreditTransactionPayload) {
  try {
    // 1. Calculate totals
    const itemTotal = payload.items.reduce((sum, item) => 
      sum + (item.qty * item.harga), 0
    )
    const total = itemTotal + (payload.pajak || 0) + (payload.biaya_pengiriman || 0) - (payload.diskon || 0)
    
    // 2. Generate transaction ID
    const idTrx = buildTrxId(1, payload.pelangganId) // TODO: Get proper sequence
    
    // 3. Create transaction record
    const { error: trxError } = await supabase
      .from('sbs.transaksi')
      .insert({
        id_transaksi: idTrx,
        id_pelanggan: payload.pelangganId,
        id_pengguna: payload.penggunaId,
        total,
        status: 'menunggu',
        is_credit: true,
        dp_amount: payload.dp,
        diskon: payload.diskon,
        pajak: payload.pajak,
        biaya_pengiriman: payload.biaya_pengiriman
      })
    
    if (trxError) throw trxError

    // 4. Insert transaction details
    const transactionDetails = payload.items.map(item => ({
      id_transaksi: idTrx,
      id_produk: item.id_produk,
      jumlah: item.qty,
      harga_satuan: item.harga
    }))

    const { error: detailError } = await supabase
      .from('sbs.transaksi_detail')
      .insert(transactionDetails)
    
    if (detailError) throw detailError

    // 5. Create accounts receivable
    const principal = Math.max(0, total - payload.dp)
    const totalTagihan = principal * (1 + payload.bunga / 100)
    const idAr = buildArId(1) // TODO: Get proper sequence

    const { error: arError } = await supabase
      .from('sbs.piutang')
      .insert({
        id_piutang: idAr,
        id_transaksi: idTrx,
        id_pelanggan: payload.pelangganId,
        tenor_bulan: payload.tenor,
        dp_amount: payload.dp,
        principal,
        bunga_persen: payload.bunga,
        total_tagihan: totalTagihan,
        outstanding: totalTagihan
      })
    
    if (arError) throw arError

    // 6. Generate installment schedule
    const monthlyPayment = +(totalTagihan / payload.tenor).toFixed(2)
    const installmentSchedule = Array.from({ length: payload.tenor }, (_, index) => {
      const dueDate = new Date()
      dueDate.setMonth(dueDate.getMonth() + index + 1)
      
      return {
        id_piutang: idAr,
        termin_ke: index + 1,
        due_date: dueDate.toISOString().split('T')[0], // Format: YYYY-MM-DD
        amount_due: monthlyPayment
      }
    })

    const { error: scheduleError } = await supabase
      .from('sbs.piutang_jadwal')
      .insert(installmentSchedule)
    
    if (scheduleError) throw scheduleError

    // 7. Record down payment
    const idPay = buildPayId(1) // TODO: Get proper sequence
    
    const { error: paymentError } = await supabase
      .from('sbs.pembayaran')
      .insert({
        id_pembayaran: idPay,
        id_transaksi: idTrx,
        metode: 'non_tunai',
        jumlah: payload.dp,
        id_piutang: idAr,
        keterangan: 'Down payment for installment'
      })
    
    if (paymentError) throw paymentError

    // 8. Complete transaction
    const { error: updateError } = await supabase
      .from('sbs.transaksi')
      .update({ status: 'selesai' })
      .eq('id_transaksi', idTrx)
    
    if (updateError) throw updateError

    return { 
      success: true, 
      transactionId: idTrx, 
      arId: idAr 
    }

  } catch (error) {
    console.error('Credit transaction failed:', error)
    throw error
  }
}
```

> **Production Note:** For better atomicity and consistency, consider moving this logic to a Supabase Edge Function or RPC. The current client-side approach is suitable for MVP development but may need enhancement for production use.

## Data Seeding

### Initial System Setup

```sql
-- Admin user profile (manually map to auth.users.id after user creation)
INSERT INTO sbs.pengguna (id_pengguna, nama, email, role, user_id) VALUES
('001-ADM', 'Admin Toko', 'admin@example.com', 'admin', '00000000-0000-0000-0000-000000000000');

-- Basic product categories
INSERT INTO sbs.kategori (nama) VALUES 
('Umum'), 
('Elektronik'), 
('Sparepart'),
('Konsumsi'),
('Perawatan');

-- Sample customers
INSERT INTO sbs.pelanggan (id_pelanggan, nama, email, telepon, allow_installment, credit_limit, trust_score) VALUES 
('P001', 'Andi Wijaya', 'andi@example.com', '081234567890', true, 5000000, 85.5),
('P002', 'Budi Santoso', 'budi@example.com', '081234567891', false, 0, 45.0),
('P003', 'Citra Dewi', 'citra@example.com', '081234567892', true, 2000000, 72.3);

-- Sample products
INSERT INTO sbs.produk (id_produk, id_kategori, nama, harga, biaya_produk, stok, batas_stok) VALUES
('8999999999999', 1, 'Produk Contoh 1', 50000, 35000, 100, 10),
('8888888888888', 2, 'Elektronik Sample', 120000, 90000, 50, 5),
('7777777777777', 3, 'Sparepart ABC', 75000, 50000, 25, 3);

-- Default installment policy
INSERT INTO sbs.kebijakan_cicilan (
  min_member_days, 
  min_total_belanja_3bln, 
  min_freq_transaksi_3bln, 
  max_tunggakan_hari, 
  min_trust_score, 
  min_dp_persen, 
  max_tenor_bulan
) VALUES (30, 1000000, 3, 0, 70.0, 20.0, 12);

-- Tiered pricing example
INSERT INTO sbs.harga_aturan (id_produk, min_qty, harga_satuan, catatan) VALUES
('8999999999999', 1, 50000, 'Harga satuan'),
('8999999999999', 10, 47500, 'Diskon 5% untuk pembelian 10+'),
('8999999999999', 50, 45000, 'Diskon 10% untuk pembelian 50+');
```

## Acceptance Criteria (Phase 1)

### Core Authentication & Navigation
- ✅ User login functionality with email/password authentication
- ✅ Automatic role-based dashboard redirection after login
- ✅ Distinct layouts and navigation for Admin and Cashier roles
- ✅ Proper middleware protection for role-restricted pages

### Point of Sale Functionality
- ✅ Product search and selection (barcode scan + name search)
- ✅ Shopping cart management with real-time calculations
- ✅ **Cash payment processing** - Complete transaction workflow
- ✅ Transaction receipt generation and status tracking

### Credit/Installment System
- ✅ Customer credit eligibility verification
- ✅ Installment transaction creation with proper data relationships:
  - Create `piutang` (accounts receivable) record
  - Generate `piutang_jadwal` (installment schedule)
  - Record `pembayaran` (down payment) entry
  - Update transaction status to 'selesai' (completed)

### Performance Requirements
- ✅ All data queries use pagination (limit 20-50 records)
- ✅ Specific column selection (avoid `SELECT *` operations)
- ✅ Responsive UI with loading states and error handling
- ✅ Optimized database queries with proper indexing

### Data Integrity
- ✅ Row Level Security (RLS) implementation
- ✅ Role-based access control for data operations
- ✅ Proper foreign key relationships and constraints
- ✅ Transaction audit trail with timestamps

## Performance Guidelines & Anti-Lag Strategies

### Database Query Optimization

**Efficient Query Patterns:**
```typescript
// ✅ Good: Specific column selection
const { data } = await supabase
  .from('sbs.produk')
  .select('id_produk, nama, harga, stok')
  .range(0, 19)

// ❌ Avoid: Select all columns
const { data } = await supabase
  .from('sbs.produk')
  .select('*')
```

**Pagination Implementation:**
```typescript
// Efficient pagination with range
const startIndex = (page - 1) * pageSize
const endIndex = startIndex + pageSize - 1

const { data, count } = await supabase
  .from('sbs.produk')
  .select('id_produk, nama, harga', { count: 'exact' })
  .range(startIndex, endIndex)
```

### Frontend Performance Optimization

**Search Debouncing:**
```typescript
// Debounced search implementation
const searchTerm = ref('')
const debouncedSearch = useDebounceFn(async (term: string) => {
  if (term.length >= 2) {
    await searchProducts(term)
  }
}, 250)

watch(searchTerm, debouncedSearch)
```

**State Management Best Practices:**
- Cache frequently accessed master data (categories, policies) in Pinia
- Implement periodic refresh for cached data (every 5-10 minutes)
- Clear transaction state after completion to prevent memory leaks
- Use computed properties for derived state calculations

**UI Responsiveness:**
- Implement virtual scrolling for large product catalogs
- Use skeleton loading states during data fetching
- Optimize image loading with lazy loading and appropriate sizing
- Implement infinite scroll for better user experience

### Infrastructure Considerations

**Database Indexing:**
- All primary and foreign keys are automatically indexed
- Additional indexes provided for common query patterns
- Monitor slow queries and add indexes as needed for specific use cases

**Caching Strategy:**
- Client-side caching for master data (categories, pricing rules)
- Browser localStorage for user preferences and cart state
- Consider Redis caching for frequently accessed data in production

**Monitoring & Alerting:**
- Implement query performance monitoring
- Set up alerts for slow-running operations
- Monitor database connection pool usage
- Track user session performance metrics

## Future Enhancements

### Advanced Payment Processing

**Automated Installment Management:**
```sql
-- RPC function for installment payment processing
CREATE OR REPLACE FUNCTION pay_installment(
  p_jadwal_id BIGINT,
  p_amount NUMERIC(12,2)
) RETURNS JSON AS $$
BEGIN
  -- Update installment schedule payment status
  -- Automatically allocate overpayments to future installments
  -- Update overall accounts receivable outstanding balance
  -- Close accounts receivable when fully paid
END;
$$ LANGUAGE plpgsql;
```

**Automated Collection System:**
- **Scheduled Tasks**: Edge Functions or cron jobs for overdue detection
- **Dunning Process**: Automatic marking of overdue installments
- **Communication Integration**: SMS/WhatsApp reminder system
- **Collection Reporting**: Aging analysis and collection effectiveness metrics

### Enhanced Reporting & Analytics

**Financial Reports:**
- Detailed aging analysis for accounts receivable
- Cash flow projections based on installment schedules
- Profitability analysis by product category and customer segment

**Operational Reports:**
- Inventory turnover analysis
- Sales performance by cashier and time period
- Customer behavior analytics and segmentation

**Compliance & Audit:**
- Complete audit trail for all financial transactions
- Regulatory compliance reporting for credit operations
- Data export capabilities for external accounting systems

### System Integration

**External System Connectivity:**
- Accounting software integration (QuickBooks, SAP, etc.)
- Bank payment gateway integration
- Inventory management system synchronization
- Customer relationship management (CRM) integration

**API Development:**
- RESTful API for mobile applications
- Webhook support for real-time notifications
- Third-party developer documentation and SDKs

---

**Project Completion Summary**

This comprehensive technical specification provides a complete roadmap for developing a modern Point of Sale system with sophisticated credit management capabilities. The architecture emphasizes performance, security, and scalability while maintaining simplicity for rapid development and deployment.

**Key Success Factors:**
1. **Modular Design**: Clear separation of concerns between authentication, POS operations, and credit management
2. **Performance-First Approach**: Optimized queries, pagination, and caching strategies
3. **Security by Design**: Row Level Security, role-based access control, and audit trails
4. **Scalable Architecture**: Foundation for future enhancements and integrations
5. **Developer Experience**: Clear documentation, type safety, and maintainable code structure

This specification serves as a complete guide for AI agents and development teams to implement a production-ready POS system with minimal ambiguity and maximum efficiency.
